# Stepick.org — PROкод: продвинутый курс по Python
# 13. Матрицы на чистом Python: боль, страдания и немного циклов

from sys import stdin


# pylint: disable=W0105


# 13.1 Основы работы с матрицами


# === Задача 1. Сумма строк ===
"""
    Шаг 1. Объяви функцию row_sums(matrix),
        где matrix --> список списков чисел.
    Шаг 2. Для каждой строки матрицы вычисли сумму её элементов.
    Шаг 3. Верни список сумм по строкам в том же порядке.
    Важно:
        - функцию не вызывать, ничего не печатать;
        - использовать только return
        - input() не использовать.
    """


def row_sums(matrix):
    sums = [sum(line) for line in matrix]
    return sums


m_13_1_1 = row_sums


# === Задача 2. Расшифровка сообщения из сетки ===
"""
    Шаг 1. Объявите функцию read_columns(matrix),
        где matrix --> список списков символов (прямоугольная таблица).
    Шаг 2. Сформируйте строку, проходя по столбцам слева направо,
        а внутри каждого столбца по строкам сверху вниз:
        берите символы как matrix[i][j].
    Шаг 3. Верните полученную строку.
    Функцию не вызывать, ничего не печатать, используйте только return.
    """


def read_columns(matrix):
    result = [matrix[i][j] for j in range(len(matrix[0])) for i in range(len(matrix))]
    return "".join(result)


m_13_1_2 = read_columns


# === Задача 3. Сбой в Центре Управления Сетью ===
"""
    Шаг 1. Объяви функцию matrix_add(a, b),
        где a и b --> матрицы.
    Шаг 2. Если размеры матриц не совпадают
        (разное число строк или столбцов), верни строку ровно:
        Матрицы разного размера - сложение невозможно.
    Шаг 3. Иначе верни новую матрицу -->
        поэлементную сумму a[i][j] + b[i][j].
    Шаг 4. Ничего не печатать и не вызывать, использовать только return.
        Вход всегда непустой (пустых матриц нет).
    """


def matrix_add(a, b):
    if len(a) != len(b) or len(a[0]) != len(b[0]):
        return "Матрицы разного размера - сложение невозможно."
    result = [[a[i][j] + b[i][j] for j in range(len(a[0]))] for i in range(len(a))]
    return result


m_13_1_3 = matrix_add


# === Задача 4. Перехват данных с орбитального спутника ===
"""
    Шаг 1. Объявите функцию transpose(matrix), где matrix это
        прямоугольная матрица (список списков одинаковой длины).
    Шаг 2. Верните новую матрицу, транспонированную версию исходной
        (строки становятся столбцами, столбцы --> строками).
    Шаг 3. Ничего не печатайте и не вызывайте функцию,
        используйте только return.
    Ограничения:
        - Нельзя использовать import, а также функции zip и map.
        - Формируйте результат по индексам: внешний цикл --> по столбцам,
            внутренний --> по строкам.
    """


def transpose(matrix):
    result = [[matrix[i][j] for i in range(len(matrix))] for j in range(len(matrix[0]))]
    return result


m_13_1_4 = transpose


# === Задача 5. Печать Древнего Оракула ===
"""
    Шаг 1. Объявите функцию determinant_3x3(matrix),
        которая принимает квадратную матрицу 3х3
        (список из трёх списков по три числа).
    Шаг 2. Если матрица не имеет форму 3х3, выбросьте исключение
        (например, ValueError) с понятным сообщением.
    Шаг 3. Вычислите определитель по формуле:
        Обозначим элементы как
        a b c
        d e f
        g h i
        Тогда
        det = a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g)
    Шаг 4. Верните вычисленное значение.
    Функцию не вызывать и ничего не печатать, используйте только return.
    """


def determinant_3x3(matrix):
    def det(n, num, m):
        return num * (-1) ** n * (m[0][0] * m[1][1] - m[0][1] * m[1][0])

    if len(matrix) != 3 or len(matrix[0]) != 3:
        raise ValueError("Неверный размер матрицы")
    sum = 0
    for n, num in enumerate(matrix[0]):
        m = [[el for i, el in enumerate(line) if i != n] for line in matrix[1:]]
        sum += det(n, num, m)
    return sum


m_13_1_5 = determinant_3x3


# === Задача 6. Архитектор Сети: умножение матриц ===
"""
    Шаг 1. Объяви функцию matrix_multiply(a, b),
        где a и b --> прямоугольные матрицы (списки списков).
    Шаг 2. Проверь совместимость размеров:
        - число столбцов a должно быть равно числу строк b.
        — если несовместимы, верни ровно строку:
            ❌ Матрицы несовместимы - нельзя перемножить
    Шаг 3. Иначе верни новую матрицу c размера len(a) х len(b[0]),
        где c[i][j] = Σ a[i][k] * b[k][j] по всем k.
    Шаг 4. Функцию не вызывать, ничего не печатать, только return.
        Библиотеки и готовые решения не использовать.
    """


def matrix_multiply(a, b):
    if len(a[0]) != len(b):
        return "❌ Матрицы несовместимы - нельзя перемножить"

    def multiply(i, j):
        line = a[i]
        col = [row[j] for row in b]
        result = sum(num1 * num2 for num1, num2 in zip(line, col))
        return result

    result = [[multiply(i, j) for j in range(len(b[0]))] for i in range(len(a))]
    return result


m_13_1_6 = matrix_multiply


# === Задача 7. Матрица Сознания ===
"""
    Шаг 1. Объявите функцию is_double_diagonal_equal(matrix),
        где matrix это список списков одинаковой длины.
    Шаг 2. Если матрица не квадратная (число строк не равно числу столбцов),
        верните ровно строку:
            Матрица не квадратная
    Шаг 3. Сформируйте две последовательности длины n:
        - главная диагональ: matrix[i][i] для i = 0..n-1;
        - побочная диагональ (справа налево): matrix[i][n-1-i] для i = 0..n-1.
    Шаг 4. Верните True, если эти две последовательности полностью совпадают
        (включая порядок элементов), иначе False.
    Шаг 5. Функцию не вызывать, ничего не печатать, используйте только return.
        input() не использовать.
    """


def is_double_diagonal_equal(matrix):
    size = len(matrix)
    if size != len(matrix[0]):
        return "Матрица не квадратная"

    main, secondary = [], []
    for i in range(size):
        main.append(matrix[i][i])
        secondary.append(matrix[i][size - 1 - i])
    return main == secondary


m_13_1_7 = is_double_diagonal_equal


# === Задача 8. Ядро Хроноса ===
"""
    Объяви функцию is_diagonal_layer_balance(matrix), которая:
        - Принимает квадратную матрицу нечётного размера n х n.
        - Делит её на вложенные слои (рамки):
            - слой k ограничен индексами от k до n-1-k по строкам и столбцам,
              где k = 0, 1, …, (n//2).
        - Для каждого слоя k вычисляет:
            - сумму главной диагонали слоя:
              элементы с координатами (k+i, k+i), i = 0..(len_layer-1);
            - сумму побочной диагонали слоя:
              элементы с координатами (k+i, (n-1-k)-i), i = 0..(len_layer-1),
              где len_layer = n - 2k.
        - Возвращает True, если во всех слоях суммы диагоналей совпадают;
          иначе --> False.

    Если матрица не квадратная или размер чётный, вернуть строку ровно:
        Матрица не подходит
    Ограничения и подсказки
        - Матрица гарантированно непустая.
        - import не использовать!
        - Сложность решения должна быть O(n²) --> каждый элемент
          учитывается не более одного раза в «своём» слое.
        - Центральный элемент (в самом внутреннем слое при нечётном n)
          попадает одновременно на обе диагонали; он учитывается оба раза
          это корректно, потому что присутствует по одному разу в каждой сумме.
    """


def is_diagonal_layer_balance(matrix):
    size = len(matrix)
    if size != len(matrix[0]) or size % 2 == 0:
        return "Матрица не подходит"
    main, secondary = [], []
    for i in range(size):
        main.append(matrix[i][i])
        secondary.append(matrix[i][size - 1 - i])
    for i in range(size // 2):
        m = main[i : size - i]
        s = secondary[i : size - i]
        if sum(s) != sum(m):
            return False
    return True


m_13_1_8 = is_diagonal_layer_balance
